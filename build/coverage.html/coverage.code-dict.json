{"/home/travis/build/npmtest/node-npmtest-cordova-plugin-bluetoothle/test.js":"/* istanbul instrument in package npmtest_cordova_plugin_bluetoothle */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-bluetoothle/lib.npmtest_cordova_plugin_bluetoothle.js":"/* istanbul instrument in package npmtest_cordova_plugin_bluetoothle */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_cordova_plugin_bluetoothle = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_cordova_plugin_bluetoothle = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-bluetoothle/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-cordova-plugin-bluetoothle && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_cordova_plugin_bluetoothle */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_cordova_plugin_bluetoothle\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_cordova_plugin_bluetoothle.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_cordova_plugin_bluetoothle.rollup.js'] =\n            local.assetsDict['/assets.npmtest_cordova_plugin_bluetoothle.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_cordova_plugin_bluetoothle.__dirname + '/lib.npmtest_cordova_plugin_bluetoothle.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-bluetoothle/node_modules/cordova-plugin-bluetoothle/www/bluetoothle.js":"var bluetoothleName = \"BluetoothLePlugin\";\nvar bluetoothle = {\n  initialize: function(successCallback, params) {\n    cordova.exec(successCallback, successCallback, bluetoothleName, \"initialize\", [params]);\n  },\n  enable: function(successCallback, errorCallback) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"enable\", []);\n  },\n  disable: function(successCallback, errorCallback) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"disable\", []);\n  },\n  startScan: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"startScan\", [params]);\n  },\n  stopScan: function(successCallback, errorCallback) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"stopScan\", []);\n  },\n  retrieveConnected: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"retrieveConnected\", [params]);\n  },\n  bond: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"bond\", [params]);\n  },\n  unbond: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"unbond\", [params]);\n  },\n  connect: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"connect\", [params]);\n  },\n  reconnect: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"reconnect\", [params]);\n  },\n  disconnect: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"disconnect\", [params]);\n  },\n  close: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"close\", [params]);\n  },\n  discover: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"discover\", [params]);\n  },\n  services: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"services\", [params]);\n  },\n  characteristics: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"characteristics\", [params]);\n  },\n  descriptors: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"descriptors\", [params]);\n  },\n  read: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"read\", [params]);\n  },\n  subscribe: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"subscribe\", [params]);\n  },\n  unsubscribe: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"unsubscribe\", [params]);\n  },\n  write: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"write\", [params]);\n  },\n  writeQ: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"writeQ\", [params]);\n  },\n  readDescriptor: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"readDescriptor\", [params]);\n  },\n  writeDescriptor: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"writeDescriptor\", [params]);\n  },\n  rssi: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"rssi\", [params]);\n  },\n  mtu: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"mtu\", [params]);\n  },\n  requestConnectionPriority: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"requestConnectionPriority\", [params]);\n  },\n  isInitialized: function(successCallback) {\n    cordova.exec(successCallback, successCallback, bluetoothleName, \"isInitialized\", []);\n  },\n  isEnabled: function(successCallback) {\n    cordova.exec(successCallback, successCallback, bluetoothleName, \"isEnabled\", []);\n  },\n  isScanning: function(successCallback) {\n    cordova.exec(successCallback, successCallback, bluetoothleName, \"isScanning\", []);\n  },\n  isBonded: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"isBonded\", [params]);\n  },\n  wasConnected: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"wasConnected\", [params]);\n  },\n  isConnected: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"isConnected\", [params]);\n  },\n  isDiscovered: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"isDiscovered\", [params]);\n  },\n  hasPermission: function(successCallback, errorCallback) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"hasPermission\", []);\n  },\n  requestPermission: function(successCallback, errorCallback) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"requestPermission\", []);\n  },\n  isLocationEnabled: function(successCallback, errorCallback) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"isLocationEnabled\", []);\n  },\n  requestLocation: function(successCallback, errorCallback) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"requestLocation\", []);\n  },\n  initializePeripheral: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"initializePeripheral\", [params]);\n  },\n  addService: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"addService\", [params]);\n  },\n  removeService: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"removeService\", [params]);\n  },\n  removeAllServices: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"removeAllServices\", [params]);\n  },\n  startAdvertising: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"startAdvertising\", [params]);\n  },\n  stopAdvertising: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"stopAdvertising\", [params]);\n  },\n  isAdvertising: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"isAdvertising\", []);\n  },\n  respond: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"respond\", [params]);\n  },\n  notify: function(successCallback, errorCallback, params) {\n    cordova.exec(successCallback, errorCallback, bluetoothleName, \"notify\", [params]);\n  },\n  encodedStringToBytes: function(string) {\n    var data = atob(string);\n    var bytes = new Uint8Array(data.length);\n    for (var i = 0; i < bytes.length; i++)\n    {\n      bytes[i] = data.charCodeAt(i);\n    }\n    return bytes;\n  },\n  bytesToEncodedString: function(bytes) {\n    return btoa(String.fromCharCode.apply(null, bytes));\n  },\n  stringToBytes: function(string) {\n    var bytes = new ArrayBuffer(string.length * 2);\n    var bytesUint16 = new Uint16Array(bytes);\n    for (var i = 0; i < string.length; i++) {\n      bytesUint16[i] = string.charCodeAt(i);\n    }\n    return new Uint8Array(bytesUint16);\n  },\n  bytesToString: function(bytes) {\n    return String.fromCharCode.apply(null, new Uint16Array(bytes));\n  },\n  bytesToHex: function(bytes) {\n    var string = [];\n    for (var i = 0; i < bytes.length; i++) {\n      string.push(\"0x\" + (\"0\"+(bytes[i].toString(16))).substr(-2).toUpperCase());\n    }\n    return string.join(\" \");\n  },\n  SCAN_MODE_OPPORTUNISTIC: -1,\n  SCAN_MODE_LOW_POWER: 0,\n  SCAN_MODE_BALANCED: 1,\n  SCAN_MODE_LOW_LATENCY: 2,\n  MATCH_NUM_ONE_ADVERTISEMENT: 1,\n  MATCH_NUM_FEW_ADVERTISEMENT: 2,\n  MATCH_NUM_MAX_ADVERTISEMENT: 3,\n  MATCH_MODE_AGGRESSIVE: 1,\n  MATCH_MODE_STICKY: 2,\n  CALLBACK_TYPE_ALL_MATCHES: 1,\n  CALLBACK_TYPE_FIRST_MATCH: 2,\n  CALLBACK_TYPE_MATCH_LOST: 4,\n}\nmodule.exports = bluetoothle;\n","/home/travis/build/npmtest/node-npmtest-cordova-plugin-bluetoothle/node_modules/cordova-plugin-bluetoothle/src/windows/BluetoothLePlugin.js":"var bluetooth = Windows.Devices.Bluetooth;\nvar gatt = Windows.Devices.Bluetooth.GenericAttributeProfile;\nvar deviceInfo = Windows.Devices.Enumeration.DeviceInformation;\nvar wsc = Windows.Security.Cryptography;\n\nvar WATCHER, scanCallback;\nvar WATCH_CACHE = {};\n\nvar initialized = false;\nvar cachedServices = [];\n\nmodule.exports = {\n\n  initialize: function (successCallback, errorCallback, params) {\n\n    // If Windows.Devices.Radios namespace is available we will try to use it for\n    // initialization. Otherwise fall back to default behaviour which is to\n    // search for all Gatt-enabled devices around. See randdusing/cordova-plugin-bluetoothle/#284\n    if (Windows.Devices.Radios) {\n      return module.exports.initialize2(successCallback, errorCallback, params);\n    }\n\n    var selector = \"System.Devices.InterfaceClassGuid:=\\\"{6E3BB679-4372-40C8-9EAA-4509DF260CD8}\\\" AND System.Devices.InterfaceEnabled:=System.StructuredQueryType.Boolean#True\";\n    deviceInfo.findAllAsync(selector, null).then(function (devices) {\n      if (devices.length > 0) {\n        initialized = true;\n        successCallback({ status: \"enabled\" });\n      } else {\n        if (params && params.length > 0 && params[0].request) {\n          try {\n            Windows.UI.ApplicationSettings.SettingsPane.show();\n          } catch (ex) {\n            Windows.System.Launcher.launchUriAsync(Windows.Foundation.Uri(\"ms-settings-bluetooth:\"));\n          }\n        }\n        errorCallback({ error: \"initialize\", message: \"No BLE devices found.\" });\n      }\n    }, function (error) {\n      if (params && params.length > 0 && params[0].request) {\n        try {\n          Windows.UI.ApplicationSettings.SettingsPane.show();\n        } catch (ex) {\n          Windows.System.Launcher.launchUriAsync(Windows.Foundation.Uri(\"ms-settings-bluetooth:\"));\n        }\n      }\n      errorCallback({ error: \"initialize\", message: error.message });\n    });\n  },\n\n  initialize2: function (successCallback, errorCallback, params) {\n\n    var Radios = Windows.Devices.Radios;\n\n    var request = params[0] ? !!params[0].request : false;\n    var statusReceiver = params[0] ? !!params[0].statusReceiver : false;\n\n    // If statusReceiver option is specified we would report state multiple\n    // times so we need to instruct cordova not to dispose callbacks\n    var callbackOptions = statusReceiver ? { keepCallback: true } : {};\n\n    function reportAdapterState(e) {\n      var state;\n      switch (e.target.state) {\n        case Radios.RadioState.on:\n          initialized = true;\n          state = 'enabled';\n          break;\n        default:\n          initialized = false;\n          state = 'disabled';\n      }\n\n      successCallback({ status: state }, callbackOptions);\n    }\n\n    Radios.Radio.getRadiosAsync()\n    .then(function (radios) {\n      // There is a very small chance that there are more than one bluetooth\n      // radio device is available so we'll just pick the first one from the list\n      var radio = radios.filter(function (radio) {\n        return radio.kind === Radios.RadioKind.bluetooth;\n      })[0];\n\n      if (!radio) {\n        throw { error: \"initialize\", message: \"No bluetooth radios available on device\" };\n      }\n\n      if (statusReceiver) {\n        radio.addEventListener('statechanged', reportAdapterState);\n      }\n\n      reportAdapterState({ target: radio });\n\n      if (radio.state !== Radios.RadioState.on && request) {\n        // radio.setStateAsync(Windows.Devices.Radios.RadioState.on) doesn't\n        // work somehow so try to invoke settings in an old way.\n        Windows.System.Launcher.launchUriAsync(Windows.Foundation.Uri(\"ms-settings-bluetooth:\"));\n      }\n    })\n    .done(null, errorCallback);\n  },\n\n  retrieveConnected: function (successCallback, errorCallback, params) {\n    if (!initialized) {\n      errorCallback({ error: \"retrieveConnected\", message: \"Not initialized.\" });\n      return;\n    }\n\n    var services;\n    var searchServices;\n    var deviceIdsFound = [];\n    var result = [];\n    var selector = \"System.Devices.InterfaceClassGuid:=\\\"{6E3BB679-4372-40C8-9EAA-4509DF260CD8}\\\" AND System.Devices.InterfaceEnabled:=System.StructuredQueryType.Boolean#True\";\n    if (params[0].services && params[0].services.length > 0) {\n      for (var i = 0; i < params[0].services.length; i++) {\n        var uuid = params[0].services[i];\n        if (uuid.length == 4) {\n            uuid = \"0000\" + uuid + \"-0000-1000-8000-00805F9B34FB\";\n        }\n        selector += (i == 0) ? \" AND ( \" : \" OR \";\n        selector += \"System.DeviceInterface.Bluetooth.ServiceGuid:=\\\"{\" + uuid + \"}\\\"\";\n      }\n      selector += \" )\";\n    }\n    deviceInfo.findAllAsync(selector, [\"System.Devices.ContainerId\"]).then(function (devices) {\n      for (var i = 0; i < devices.length; i++) {\n        var deviceId = devices[i].properties[\"System.Devices.ContainerId\"];\n        var deviceName = devices[i].name;\n        if (deviceIdsFound.indexOf(deviceId) == -1) {\n          deviceIdsFound.push(deviceId);\n          result.push({ name: deviceName, address: deviceId });\n        }\n      }\n      successCallback(result);\n    }, function (error) {\n      errorCallback({ error: \"retrieveConnected\", message: error.message });\n    });\n  },\n\n  startScan: function (successCallback, errorCallback, params) {\n\n    var DeviceInformation = Windows.Devices.Enumeration.DeviceInformation;\n    var DeviceWatcherStatus = Windows.Devices.Enumeration.DeviceWatcherStatus;\n\n    var NAME_KEY = \"System.ItemNameDisplay\";\n    var RSSI_KEY = \"System.Devices.Aep.SignalStrength\";\n    var CONTAINER_ID_KEY = \"System.Devices.Aep.ContainerId\";\n\n    // Drop cache first\n    WATCH_CACHE = {};\n\n    if (!WATCHER) {\n      // watch BLE devices using device watcher.\n      var selector = Windows.Devices.Bluetooth.BluetoothLEDevice.getDeviceSelectorFromConnectionStatus(false);\n      WATCHER = DeviceInformation.createWatcher(selector, [NAME_KEY, RSSI_KEY, CONTAINER_ID_KEY]);\n    }\n\n    if (WATCHER.status !== DeviceWatcherStatus.started &&\n      WATCHER.status !== DeviceWatcherStatus.created &&\n      WATCHER.status !== DeviceWatcherStatus.aborted) {\n\n      errorCallback({ error: \"startScan\", message: 'Scan already in progress' });\n      return;\n    }\n\n    scanCallback = function (obj) {\n\n      if (obj.type !== 'added')\n        // We're not interested in device characteristics updates\n        // unless continuousScan === true (which is not yet supported)\n        return;\n\n      var device = obj.detail[0];\n\n      // TODO: Add \"advertisement\" property - it is not available directly\n      // but probably could be obtained using GattDeviceService\n      var deviceAddress = device.properties.hasKey(CONTAINER_ID_KEY) && device.properties.lookup(CONTAINER_ID_KEY);\n      // Put device into cache to be able to get it faster in 'connect'\n      WATCH_CACHE[deviceAddress] = device;\n\n      var deviceInfo = {\n        status: 'scanResult',\n        rssi: device.properties.hasKey(RSSI_KEY) && device.properties.lookup(RSSI_KEY),\n        name: device.properties.hasKey(NAME_KEY) && device.properties.lookup(NAME_KEY),\n        address: deviceAddress\n      };\n\n      successCallback(deviceInfo, { keepCallback: true });\n    };\n\n    WATCHER.addEventListener(\"added\", scanCallback, false);\n    // Although we're not interested in device characteristics updated we still need to attach\n    // listener to 'updated' event to catch devices that could be found after the initial scan is completed\n    WATCHER.addEventListener(\"updated\", scanCallback, false);\n    WATCHER.start();\n\n    successCallback({ status: 'scanStarted' }, { keepCallback: true });\n  },\n\n  stopScan: function (successCallback, errorCallback) {\n    var DeviceWatcherStatus = Windows.Devices.Enumeration.DeviceWatcherStatus;\n\n    if (WATCHER && (WATCHER.status === DeviceWatcherStatus.started ||\n      WATCHER.status === DeviceWatcherStatus.enumerationCompleted)) {\n\n      WATCHER.stop();\n      WATCHER.removeEventListener(\"added\", scanCallback);\n      WATCHER.removeEventListener(\"updated\", scanCallback);\n\n      successCallback({ status: \"scanStopped\" });\n      return;\n    }\n\n    errorCallback({ error: \"stopScan\", message: \"Scan is either not yet started or already stopped\" });\n  },\n\n  connect: function (successCallback, errorCallback, params) {\n    if (!initialized) {\n      errorCallback({ error: \"connect\", message: \"Not initialized.\" });\n      return;\n    }\n\n    var address = params && params[0] && params[0].address;\n    if (!address) {\n      errorCallback({ error: \"connect\", message: \"Device address is not specified\" });\n      return;\n    }\n\n    var DeviceInformation = Windows.Devices.Enumeration.DeviceInformation;\n    var DeviceInformationKind = Windows.Devices.Enumeration.DeviceInformationKind;\n\n    WinJS.Promise.wrap(address)\n    .then(function (deviceAddress) {\n      // If we have cached device info return it right now\n      if (WATCH_CACHE[deviceAddress]) return [WATCH_CACHE[deviceAddress]];\n      // Otherwise try to search it again\n      var selector = \"System.Devices.Aep.ProtocolId:=\\\"{bb7bb05e-5972-42b5-94fc-76eaa7084d49}\\\" AND \" +\n                      \"System.Devices.Aep.ContainerId:=\\\"{\" + deviceAddress + \"}\\\" AND \" +\n                      \"(System.Devices.Aep.CanPair:=System.StructuredQueryType.Boolean#True OR \" +\n                      \"System.Devices.Aep.IsPaired:=System.StructuredQueryType.Boolean#True)\";\n      return DeviceInformation.findAllAsync(selector, [\"System.Devices.Aep.ContainerId\"], DeviceInformationKind.associationEndpoint);\n    })\n    .then(function (devices) {\n      return Windows.Devices.Bluetooth.BluetoothLEDevice.fromIdAsync(devices[0].id);\n    })\n    .then(function (bleDevice) {\n      var DevicePairingProtectionLevel = Windows.Devices.Enumeration.DevicePairingProtectionLevel;\n      var DevicePairingResultStatus = Windows.Devices.Enumeration.DevicePairingResultStatus;\n\n      if (bleDevice.deviceInformation.pairing.isPaired) {\n        return bleDevice;\n      }\n\n      if (!bleDevice.deviceInformation.pairing.canPair) {\n        throw { error: \"connect\", message: \"The device does not support pairing\" };\n      }\n\n      // TODO: investigate if it is possible to pair without user prompt\n      return bleDevice.deviceInformation.pairing.pairAsync(DevicePairingProtectionLevel.none)\n      .then(function (res) {\n        if (res.status === DevicePairingResultStatus.paired ||\n            res.status === DevicePairingResultStatus.alreadyPaired)\n          return bleDevice;\n\n        // TODO: provide error code based on DevicePairingResultStatus.alreadyPaired enum\n        throw { error: \"connect\", message: \"The device rejected the connection\" };\n      });\n    })\n    .done(function (bleDevice) {\n      var result = {\n        name: bleDevice.deviceInformation.name,\n        address: address,\n        status: \"connected\"\n      };\n\n      // Attach listener to device to report disconnected event\n      bleDevice.addEventListener('connectionstatuschanged', function connectionStatusListener(e) {\n        if (e.target.connectionStatus === Windows.Devices.Bluetooth.BluetoothConnectionStatus.disconnected) {\n          result.status = \"disconnected\";\n          successCallback(result);\n          bleDevice.removeEventListener('connectionstatuschanged', connectionStatusListener);\n        }\n      });\n\n      // Need to use keepCallback to be able to report \"disconnect\" event\n      // https://github.com/randdusing/cordova-plugin-bluetoothle#connect\n      successCallback(result, { keepCallback: true });\n    }, function (err) {\n      errorCallback(err);\n    });\n  },\n\n  close: function (successCallback, errorCallback, params) {\n    if (!initialized) {\n      errorCallback({ error: \"close\", message: \"Not initialized.\" });\n      return;\n    }\n\n    if (params && params.length > 0 && params[0].address) {\n      var deviceId = params[0].address;\n\n      for (var i = 0; i < cachedServices.length;) {\n        var service = cachedServices[i];\n        if (service.deviceId == deviceId) {\n          cachedServices.splice(i, 1);\n          service.deviceService.close();\n        } else {\n          i++;\n        }\n      }\n    }\n  },\n\n  services: function (successCallback, errorCallback, params) {\n    if (!initialized) {\n      errorCallback({ error: \"services\", message: \"Not initialized.\" });\n      return;\n    }\n\n    if (params && params.length > 0 && params[0].address) {\n      var deviceId = params[0].address;\n      var selector = \"System.Devices.ContainerId:={\" + deviceId + \"} AND System.Devices.InterfaceClassGuid:=\\\"{6E3BB679-4372-40C8-9EAA-4509DF260CD8}\\\" AND System.Devices.InterfaceEnabled:=System.StructuredQueryType.Boolean#True\";\n      deviceInfo.findAllAsync(selector, null).then(function (services) {\n        if (services.length > 0) {\n          var deviceName;\n          var serviceIds = [];\n          for (var i = 0; i < services.length; i++) {\n              var UuidRe = /\\{([0-9a-f]{8}\\-[0-9a-f]{4}\\-[0-9a-f]{4}\\-[0-9a-f]{4}\\-[0-9a-f]{12})\\}_/;\n              var serviceId = UuidRe.exec(services[i].id)[1];\n              var re = /0000([0-9a-f]{4})\\-0000\\-1000\\-8000\\-00805f9b34fb/;\n              var shortUuidMatch = re.exec(serviceId);\n              if (shortUuidMatch != null) {\n                serviceId = shortUuidMatch[1];\n              }\n              serviceIds.push(serviceId);\n              deviceName = services[i].name;\n          }\n          successCallback({ status: \"services\", services: serviceIds, name: deviceName, address: deviceId });\n        } else {\n          errorCallback({ error: \"services\", message: \"Device not found.\" });\n        }\n      }, function (error) {\n        errorCallback({ error: \"services\", message: error.message });\n      });\n    } else {\n      errorCallback({ error: \"services\", message: \"Invalid parameters.\" });\n    }\n  },\n\n  characteristics: function (successCallback, errorCallback, params) {\n    if (!initialized) {\n      errorCallback({ error: \"characteristics\", message: \"Not initialized.\" });\n      return;\n    }\n\n    if (params && params.length > 0 && params[0].address && params[0].service) {\n      var deviceId = params[0].address;\n      var serviceId = params[0].service;\n\n      getService(deviceId, serviceId).then(function (service) {\n        var characteristicsResult = [];\n        if (service.getAllCharacteristics) { // Phone\n          var characteristics = service.getAllCharacteristics();\n          for (var i = 0; i < characteristics.length; i++) {\n            characteristicsResult.push(convertCharacteristic(characteristics[i]));\n          }\n        } else { // Client\n          var serviceInfo = getServiceInfo(serviceId);\n          if (serviceInfo) {\n            for (var i = 0; i < serviceInfo.characteristics.length; i++) {\n              var characteristicInfo = serviceInfo.characteristics[i];\n              var characteristic = service.getCharacteristics(gatt.GattCharacteristic.convertShortIdToUuid(characteristicInfo.uuid))[0];\n              if (characteristic) {\n                characteristicsResult.push(convertCharacteristic(characteristic));\n              }\n            }\n          } else {\n            errorCallback({ error: \"characteristics\", message: \"Unknown service, add the service to getServiceInfos() and try again.\" });\n          }\n        }\n        successCallback({ status: \"characteristics\", characteristics: characteristicsResult, name: service.name, service: serviceId, address: deviceId });\n      }, function (error) {\n        errorCallback({ error: \"characteristics\", message: error });\n      });\n    } else {\n      errorCallback({ error: \"characteristics\", message: \"Invalid parameters.\" });\n    }\n  },\n\n  descriptors: function (successCallback, errorCallback, params) {\n    if (!initialized) {\n      errorCallback({ error: \"descriptors\", message: \"Not initialized.\" });\n      return;\n    }\n\n    if (params && params.length > 0 && params[0].address && params[0].service && params[0].characteristic) {\n      var deviceId = params[0].address;\n      var serviceId = params[0].service;\n      var characteristicId = params[0].characteristic;\n\n      getCharacteristic(deviceId, serviceId, characteristicId).then(function (characteristic, deviceName) {\n        var descriptorIds = [];\n        if (characteristic.getAllDescriptors) { // Phone\n          var descriptors = characteristic.getAllDescriptors();\n          for (var i = 0; i < descriptors.length; i++) {\n            descriptorIds.push(descriptors[i].uuid.substring(4, 8));\n          }\n        } else { // Client\n          var characteristicInfo = getCharacteristicsInfo(serviceId, characteristicId);\n          for (var i = 0; i < characteristicInfo.descriptors.length; i++) {\n            var descriptors = characteristic.getDescriptors(gatt.GattDescriptor.convertShortIdToUuid(characteristicInfo.descriptors[i]));\n            for (var j = 0; j < descriptors.length; j++) {\n              descriptorIds.push(descriptors[j].uuid.substring(4, 8));\n            }\n          }\n        }\n        successCallback({ status: \"descriptors\", descriptors: descriptorIds, characteristic: characteristicId, name: deviceName, service: serviceId, address: deviceId });\n      }, function (error) {\n        errorCallback({ error: \"descriptors\", message: error });\n      });\n    } else {\n      errorCallback({ error: \"descriptors\", message: \"Invalid parameters.\" });\n    }\n  },\n\n  read: function (successCallback, errorCallback, params) {\n    if (!initialized) {\n      errorCallback({ error: \"read\", message: \"Not initialized.\" });\n      return;\n    }\n\n    if (params && params.length > 0 && params[0].address && params[0].service && params[0].characteristic) {\n      var deviceId = params[0].address;\n      var serviceId = params[0].service;\n      var characteristicId = params[0].characteristic;\n\n      getCharacteristic(deviceId, serviceId, characteristicId).then(function (characteristic, deviceName) {\n        try {\n          characteristic.readValueAsync(bluetooth.BluetoothCacheMode.uncached).done(function (result) {\n            if (result.status == gatt.GattCommunicationStatus.success) {\n              var value = wsc.CryptographicBuffer.encodeToBase64String(result.value);\n              successCallback({ status: \"read\", value: value, characteristic: characteristicId, name: deviceName, service: serviceId, address: deviceId });\n            } else {\n              errorCallback({ error: \"read\", message: \"Device unreachable.\" });\n            }\n          }, function (error) {\n            errorCallback({ error: \"read\", message: error.message });\n          });\n        } catch (error) {\n          errorCallback({ error: \"read\", message: error.message });\n        }\n      }, function (error) {\n        errorCallback({ error: \"read\", message: error });\n      });\n    } else {\n      errorCallback({ error: \"read\", message: \"Invalid parameters.\" });\n    }\n  },\n\n  subscribe: function (successCallback, errorCallback, params) {\n    if (!initialized) {\n      errorCallback({ error: \"subscribe\", message: \"Not initialized.\" });\n      return;\n    }\n\n    if (params && params.length > 0 && params[0].address && params[0].service && params[0].characteristic && params[0].isNotification != undefined) {\n      var deviceId = params[0].address;\n      var serviceId = params[0].service;\n      var characteristicId = params[0].characteristic;\n      var isNotification = params[0].isNotification;\n\n      getCharacteristic(deviceId, serviceId, characteristicId).then(function (characteristic, deviceName) {\n        var descriptorValue;\n        if (isNotification || isNotification == null) {\n          descriptorValue = gatt.GattClientCharacteristicConfigurationDescriptorValue.notify;\n        } else {\n          descriptorValue = gatt.GattClientCharacteristicConfigurationDescriptorValue.indicate;\n        }\n        characteristic.writeClientCharacteristicConfigurationDescriptorAsync(descriptorValue).done(function (result) {\n          if (result == gatt.GattCommunicationStatus.success) {\n            successCallback({ status: \"subscribed\", characteristic: characteristicId, name: deviceName, service: serviceId, address: deviceId }, { keepCallback: true });\n            characteristic.onvaluechanged = function (result) {\n              var value = wsc.CryptographicBuffer.encodeToBase64String(result.characteristicValue);\n              successCallback({ status: \"subscribedResult\", value: value, characteristic: characteristicId, name: deviceName, service: serviceId, address: deviceId }, { keepCallback: true });\n            };\n          } else {\n            errorCallback({ error: \"subscribe\", message: \"Device unreachable.\" });\n          }\n        }, function (error) {\n          errorCallback({ error: \"subscribe\", message: error.message });\n        });\n      }, function (error) {\n        errorCallback({ error: \"subscribe\", message: error });\n      });\n    } else {\n      errorCallback({ error: \"subscribe\", message: \"Invalid parameters.\" });\n    }\n  },\n\n  unsubscribe: function (successCallback, errorCallback, params) {\n    if (!initialized) {\n      errorCallback({ error: \"unsubscribe\", message: \"Not initialized.\" });\n      return;\n    }\n\n    if (params && params.length > 0 && params[0].address && params[0].service && params[0].characteristic) {\n      var deviceId = params[0].address;\n      var serviceId = params[0].service;\n      var characteristicId = params[0].characteristic;\n\n      getCharacteristic(deviceId, serviceId, characteristicId).then(function (characteristic, deviceName) {\n        characteristic.onvaluechanged = null;\n        characteristic.writeClientCharacteristicConfigurationDescriptorAsync(gatt.GattClientCharacteristicConfigurationDescriptorValue.none).done(function (result) {\n          if (result == gatt.GattCommunicationStatus.success) {\n            successCallback({ status: \"unsubscribed\", characteristic: characteristicId, name: deviceName, service: serviceId, address: deviceId });\n          } else {\n            errorCallback({ error: \"unsubscribe\", message: \"Device unreachable.\" });\n          }\n        }, function (error) {\n          errorCallback({ error: \"unsubscribe\", message: error.message });\n        });\n      }, function (error) {\n        errorCallback({ error: \"unsubscribe\", message: error });\n      });\n    } else {\n      errorCallback({ error: \"unsubscribe\", message: \"Invalid parameters.\" });\n    }\n  },\n\n  write: function (successCallback, errorCallback, params) {\n    if (!initialized) {\n      errorCallback({ error: \"write\", message: \"Not initialized.\" });\n      return;\n    }\n\n    if (params && params.length > 0 && params[0].address && params[0].service && params[0].characteristic && params[0].value) {\n      var deviceId = params[0].address;\n      var serviceId = params[0].service;\n      var characteristicId = params[0].characteristic;\n      var value = params[0].value;\n      var writeOption;\n      if (params[0].type !== undefined && params[0].type == \"noResponse\") {\n          writeOption = gatt.GattWriteOption.writeWithoutResponse;\n      } else {\n          writeOption = gatt.GattWriteOption.writeWithResponse;\n      }\n\n      getCharacteristic(deviceId, serviceId, characteristicId).then(function (characteristic, deviceName) {\n        var buffer = wsc.CryptographicBuffer.decodeFromBase64String(value);\n        characteristic.writeValueAsync(buffer, writeOption).done(function (result) {\n          if (result == gatt.GattCommunicationStatus.success) {\n            successCallback({ status: \"written\", characteristic: characteristicId, name: deviceName, service: serviceId, address: deviceId });\n          } else {\n            errorCallback({ error: \"write\", message: \"Device unreachable.\" });\n          }\n        }, function (error) {\n          errorCallback({ error: \"write\", message: error.message });\n        });\n      }, function (error) {\n        errorCallback({ error: \"write\", message: error });\n      });\n    } else {\n      errorCallback({ error: \"write\", message: \"Invalid parameters.\" });\n    }\n  },\n\n  readDescriptor: function (successCallback, errorCallback, params) {\n    if (!initialized) {\n      errorCallback({ error: \"readDescriptor\", message: \"Not initialized.\" });\n      return;\n    }\n\n    if (params && params.length > 0 && params[0].address && params[0].service && params[0].characteristic && params[0].descriptor) {\n      var deviceId = params[0].address;\n      var serviceId = params[0].service;\n      var characteristicId = params[0].characteristic;\n      var descriptorId = params[0].descriptor;\n\n      getDescriptor(deviceId, serviceId, characteristicId, descriptorId).then(function (descriptor, deviceName) {\n        descriptor.readValueAsync(bluetooth.BluetoothCacheMode.uncached).done(function (result) {\n          if (result.status == gatt.GattCommunicationStatus.success) {\n            var value = wsc.CryptographicBuffer.encodeToBase64String(result.value);\n            successCallback({ status: \"readDescriptor\", value: value, descriptor: descriptorId, characteristic: characteristicId, name: deviceName, service: serviceId, address: deviceId });\n          } else {\n            errorCallback({ error: \"readDescriptor\", message: \"Device unreachable.\" });\n          }\n        }, function (error) {\n          errorCallback({ error: \"readDescriptor\", message: error.message });\n        });\n      }, function (error) {\n        errorCallback({ error: \"readDescriptor\", message: error });\n      });\n    } else {\n      errorCallback({ error: \"readDescriptor\", message: \"Invalid parameters.\" });\n    }\n  },\n\n  writeDescriptor: function (successCallback, errorCallback, params) {\n    if (!initialized) {\n      errorCallback({ error: \"writeDescriptor\", message: \"Not initialized.\" });\n      return;\n    }\n\n    if (params && params.length > 0 && params[0].address && params[0].service && params[0].characteristic && params[0].descriptor && params[0].value) {\n      var deviceId = params[0].address;\n      var serviceId = params[0].service;\n      var characteristicId = params[0].characteristic;\n      var descriptorId = params[0].descriptor;\n      var value = params[0].value;\n\n      getDescriptor(deviceId, serviceId, characteristicId, descriptorId).then(function (descriptor, deviceName) {\n        var buffer = wsc.CryptographicBuffer.decodeFromBase64String(value);\n        descriptor.writeValueAsync(buffer).done(function (result) {\n          if (result == gatt.GattCommunicationStatus.success) {\n            successCallback({ status: \"writeDescriptor\", descriptor: descriptorId, characteristic: characteristicId, name: deviceName, service: serviceId, address: deviceId });\n          } else {\n            errorCallback({ error: \"writeDescriptor\", message: \"Device unreachable.\" });\n          }\n        }, function (error) {\n          errorCallback({ error: \"writeDescriptor\", message: error.message });\n        });\n      }, function (error) {\n        errorCallback({ error: \"writeDescriptor\", message: error });\n      });\n    } else {\n      errorCallback({ error: \"writeDescriptor\", message: \"Invalid parameters.\" });\n    }\n  },\n\n  isInitialized: function (successCallback, errorCallback, strInput) {\n    successCallback({ isInitialized: initialized });\n  },\n\n};\n\nfunction getService(deviceId, serviceId) {\n  return new WinJS.Promise(function (successCallback, errorCallback, progressDispatch) {\n    for (var i = 0; i < cachedServices.length; i++) {\n      var service = cachedServices[i];\n      if (service.deviceId == deviceId && service.serviceId == serviceId) {\n        successCallback(service.deviceService);\n        return;\n      }\n    }\n    if (serviceId.length == 4) {\n        serviceId = \"0000\" + serviceId + \"-0000-1000-8000-00805F9B34FB\";\n    }\n    var selector = \"System.Devices.ContainerId:={\" + deviceId + \"} AND System.DeviceInterface.Bluetooth.ServiceGuid:=\\\"{\" + serviceId + \"}\\\" AND System.Devices.InterfaceClassGuid:=\\\"{6E3BB679-4372-40C8-9EAA-4509DF260CD8}\\\" AND System.Devices.InterfaceEnabled:=System.StructuredQueryType.Boolean#True\";\n    deviceInfo.findAllAsync(selector, null).then(function (services) {\n      if (services.length > 0) {\n        gatt.GattDeviceService.fromIdAsync(services[0].id)\n         .then(function (deviceService) {\n           if (deviceService) {\n             cachedServices.push({ deviceId: deviceId, serviceId: serviceId, deviceService: deviceService });\n             successCallback(deviceService);\n           } else {\n             errorCallback(\"Error retrieving deviceService, check the app's permissions for this service (plugin.xml).\");\n           }\n         }, function (error) {\n           errorCallback(error);\n         });\n      } else {\n        errorCallback(\"Device or service not found.\");\n      }\n    }, function (error) {\n      errorCallback(error);\n    });\n  });\n}\n\nfunction getCharacteristic(deviceId, serviceId, characteristicId) {\n  return new WinJS.Promise(function (successCallback, errorCallback, progressDispatch) {\n    getService(deviceId, serviceId).then(function (service) {\n      var deviceName = service.name;\n      if (characteristicId.length == 4) {\n        characteristicId = gatt.GattCharacteristic.convertShortIdToUuid(parseInt(\"0x\" + characteristicId, 16));\n      }\n      var characteristics = service.getCharacteristics(characteristicId);\n      if (characteristics.length > 0) {\n        successCallback(characteristics[0], deviceName);\n      } else {\n        errorCallback(\"Characteristic not found.\");\n      }\n    }, function (error) {\n      errorCallback(error);\n    });\n  });\n}\n\nfunction getDescriptor(deviceId, serviceId, characteristicId, descriptorId) {\n  return new WinJS.Promise(function (successCallback, errorCallback, progressDispatch) {\n    getCharacteristic(deviceId, serviceId, characteristicId).then(function (characteristic, deviceName) {\n      if (descriptorId.length == 4) {\n        descriptorId = gatt.GattDescriptor.convertShortIdToUuid(parseInt(\"0x\" + descriptorId, 16))\n      }\n      var descriptors = characteristic.getDescriptors(descriptorId);\n      if (descriptors.length > 0) {\n        successCallback(descriptors[0], deviceName);\n      } else {\n        errorCallback(\"Descriptor not found.\");\n      }\n    }, function (error) {\n      errorCallback(error);\n    });\n  });\n}\n\nfunction convertCharacteristic(characteristic) {\n  var char = { uuid: characteristic.uuid.substring(4, 8), properties: new Object() };\n  if (characteristic.characteristicProperties & 1) {\n    char.properties.broadcast = \"true\";\n  }\n  if (characteristic.characteristicProperties & 2) {\n    char.properties.read = \"true\";\n  }\n  if (characteristic.characteristicProperties & 4) {\n    char.properties.writeWithoutResponse = \"true\";\n  }\n  if (characteristic.characteristicProperties & 8) {\n    char.properties.write = \"true\";\n  }\n  if (characteristic.characteristicProperties & 16) {\n    char.properties.notify = \"true\";\n  }\n  if (characteristic.characteristicProperties & 32) {\n    char.properties.indicate = \"true\";\n  }\n  if (characteristic.characteristicProperties & 64) {\n    char.properties.authenticatedSignedWrites = \"true\";\n  }\n  if (characteristic.characteristicProperties & 128) {\n    char.properties.extendedProperties = \"true\";\n  }\n  if (characteristic.characteristicProperties & 256) {\n    char.properties.reliableWrites = \"true\";\n  }\n  if (characteristic.characteristicProperties & 512) {\n    char.properties.writableAuxilaries = \"true\";\n  }\n  return char;\n}\n\nfunction getServiceInfo(serviceId) {\n  var uuid = parseInt(\"0x\" + serviceId, 16);\n  var serviceInfos = getServiceInfos();\n  for (var i = 0; i < serviceInfos.length; i++) {\n    var serviceInfo = serviceInfos[i];\n    if (serviceInfo.uuid == uuid) {\n      return serviceInfo;\n    }\n  }\n}\n\nfunction getCharacteristicsInfo(serviceId, characteristicId) {\n  var uuid = parseInt(\"0x\" + characteristicId, 16);\n  var service = getServiceInfo(serviceId);\n  for (var i = 0; i < service.characteristics.length; i++) {\n    var characteristicInfo = service.characteristics[i];\n    if (characteristicInfo.uuid == uuid) {\n      return characteristicInfo;\n    }\n  }\n}\n\nfunction getServiceInfos() {\n  return [\n   {\n     uuid: 0x1811,\n     characteristics: [\n       { uuid: 0x2A47, descriptors: [] },\n       { uuid: 0x2A46, descriptors: [0x2902, ] },\n       { uuid: 0x2A48, descriptors: [] },\n       { uuid: 0x2A45, descriptors: [0x2902, ] },\n       { uuid: 0x2A44, descriptors: [] },\n     ]\n   },\n  {\n    uuid: 0x180F,\n    characteristics: [\n      { uuid: 0x2A19, descriptors: [0x2904, 0x2902, ] },\n    ]\n  },\n  {\n    uuid: 0x1810,\n    characteristics: [\n      { uuid: 0x2A35, descriptors: [0x2902, ] },\n      { uuid: 0x2A36, descriptors: [0x2902, ] },\n      { uuid: 0x2A49, descriptors: [] },\n    ]\n  },\n  {\n    uuid: 0x181B,\n    characteristics: [\n      { uuid: 0x2A9B, descriptors: [] },\n      { uuid: 0x2A9C, descriptors: [0x2902, ] },\n    ]\n  },\n  {\n    uuid: 0x181E,\n    characteristics: [\n      { uuid: 0x2AA4, descriptors: [] },\n      { uuid: 0x2AA5, descriptors: [] },\n    ]\n  },\n  {\n    uuid: 0x181F,\n    characteristics: [\n      { uuid: 0x2AA7, descriptors: [0x2902, ] },\n      { uuid: 0x2AA8, descriptors: [] },\n      { uuid: 0x2AA9, descriptors: [] },\n      { uuid: 0x2AAA, descriptors: [] },\n      { uuid: 0x2AAB, descriptors: [] },\n      { uuid: 0x2A52, descriptors: [0x2902, ] },\n      { uuid: 0x2AAC, descriptors: [0x2902, ] },\n    ]\n  },\n  {\n    uuid: 0x1805,\n    characteristics: [\n      { uuid: 0x2A2B, descriptors: [0x2902, ] },\n      { uuid: 0x2A0F, descriptors: [] },\n      { uuid: 0x2A14, descriptors: [] },\n    ]\n  },\n  {\n    uuid: 0x1818,\n    characteristics: [\n      { uuid: 0x2A63, descriptors: [0x2902, 0x2903, ] },\n      { uuid: 0x2A65, descriptors: [] },\n      { uuid: 0x2A5D, descriptors: [] },\n      { uuid: 0x2A64, descriptors: [0x2902, ] },\n      { uuid: 0x2A66, descriptors: [0x2902, ] },\n    ]\n  },\n  {\n    uuid: 0x1816,\n    characteristics: [\n      { uuid: 0x2A5B, descriptors: [0x2902, ] },\n      { uuid: 0x2A5C, descriptors: [] },\n      { uuid: 0x2A5D, descriptors: [] },\n      { uuid: 0x2A55, descriptors: [0x2902, ] },\n    ]\n  },\n  {\n    uuid: 0x180A,\n    characteristics: [\n      { uuid: 0x2A29, descriptors: [] },\n      { uuid: 0x2A24, descriptors: [] },\n      { uuid: 0x2A25, descriptors: [] },\n      { uuid: 0x2A27, descriptors: [] },\n      { uuid: 0x2A26, descriptors: [] },\n      { uuid: 0x2A28, descriptors: [] },\n      { uuid: 0x2A23, descriptors: [] },\n      { uuid: 0x2A50, descriptors: [] },\n    ]\n  },\n  {\n    uuid: 0x181A,\n    characteristics: [\n      { uuid: 0x2A7D, descriptors: [] },\n      { uuid: 0x2A73, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A72, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A7B, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A6C, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A74, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A7A, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A6F, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A77, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A75, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A78, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A6D, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A6E, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A71, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A70, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A76, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A79, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2AA3, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2A2C, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2AA0, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n      { uuid: 0x2AA1, descriptors: [0x290C, 0x290D, 0x290B, 0x2901, 0x2906, ] },\n    ]\n  },\n  {\n    uuid: 0x1800,\n    characteristics: [\n      { uuid: 0x2A00, descriptors: [] },\n      { uuid: 0x2A01, descriptors: [] },\n      { uuid: 0x2A02, descriptors: [] },\n      { uuid: 0x2A03, descriptors: [] },\n      { uuid: 0x2A04, descriptors: [] },\n    ]\n  },\n  {\n    uuid: 0x1801,\n    characteristics: [\n      { uuid: 0x2A05, descriptors: [] },\n    ]\n  },\n  {\n    uuid: 0x1808,\n    characteristics: [\n      { uuid: 0x2A18, descriptors: [0x2902, ] },\n      { uuid: 0x2A34, descriptors: [0x2902, ] },\n      { uuid: 0x2A51, descriptors: [] },\n      { uuid: 0x2A52, descriptors: [0x2902, ] },\n    ]\n  },\n  {\n    uuid: 0x1809,\n    characteristics: [\n      { uuid: 0x2A1C, descriptors: [0x2902, ] },\n      { uuid: 0x2A1D, descriptors: [] },\n      { uuid: 0x2A1E, descriptors: [0x2902, ] },\n      { uuid: 0x2A21, descriptors: [0x2902, 0x2906, ] },\n    ]\n  },\n  {\n    uuid: 0x180D,\n    characteristics: [\n      { uuid: 0x2A37, descriptors: [0x2902, ] },\n      { uuid: 0x2A38, descriptors: [] },\n      { uuid: 0x2A39, descriptors: [] },\n    ]\n  },\n  {\n    uuid: 0x1812,\n    characteristics: [\n      { uuid: 0x2A4E, descriptors: [] },\n      { uuid: 0x2A4D, descriptors: [0x2902, 0x2908, ] },\n      { uuid: 0x2A4B, descriptors: [0x2907, ] },\n      { uuid: 0x2A22, descriptors: [0x2902, ] },\n      { uuid: 0x2A32, descriptors: [] },\n      { uuid: 0x2A33, descriptors: [0x2902, ] },\n      { uuid: 0x2A4A, descriptors: [] },\n      { uuid: 0x2A4C, descriptors: [] },\n    ]\n  },\n  {\n    uuid: 0x1802,\n    characteristics: [\n      { uuid: 0x2A06, descriptors: [] },\n    ]\n  },\n  {\n    uuid: 0x1820,\n    characteristics: [\n    ]\n  },\n  {\n    uuid: 0x1803,\n    characteristics: [\n      { uuid: 0x2A06, descriptors: [] },\n    ]\n  },\n  {\n    uuid: 0x1819,\n    characteristics: [\n      { uuid: 0x2A6A, descriptors: [] },\n      { uuid: 0x2A67, descriptors: [0x2902, ] },\n      { uuid: 0x2A69, descriptors: [] },\n      { uuid: 0x2A6B, descriptors: [0x2902, ] },\n      { uuid: 0x2A68, descriptors: [0x2902, ] },\n    ]\n  },\n  {\n    uuid: 0x1807,\n    characteristics: [\n      { uuid: 0x2A11, descriptors: [] },\n    ]\n  },\n  {\n    uuid: 0x180E,\n    characteristics: [\n      { uuid: 0x2A3F, descriptors: [0x2902, ] },\n      { uuid: 0x2A41, descriptors: [0x2902, ] },\n      { uuid: 0x2A40, descriptors: [] },\n    ]\n  },\n  {\n    uuid: 0x1806,\n    characteristics: [\n      { uuid: 0x2A16, descriptors: [] },\n      { uuid: 0x2A17, descriptors: [] },\n    ]\n  },\n  {\n    uuid: 0x1814,\n    characteristics: [\n      { uuid: 0x2A53, descriptors: [0x2902, ] },\n      { uuid: 0x2A54, descriptors: [] },\n      { uuid: 0x2A5D, descriptors: [] },\n      { uuid: 0x2A55, descriptors: [0x2902, ] },\n    ]\n  },\n  {\n    uuid: 0x1813,\n    characteristics: [\n      { uuid: 0x2A4F, descriptors: [] },\n      { uuid: 0x2A31, descriptors: [0x2902, ] },\n    ]\n  },\n  {\n    uuid: 0x1804,\n    characteristics: [\n      { uuid: 0x2A07, descriptors: [] },\n    ]\n  },\n  {\n    uuid: 0x181C,\n    characteristics: [\n      { uuid: 0x2A8A, descriptors: [] },\n      { uuid: 0x2A90, descriptors: [] },\n      { uuid: 0x2A87, descriptors: [] },\n      { uuid: 0x2A80, descriptors: [] },\n      { uuid: 0x2A85, descriptors: [] },\n      { uuid: 0x2A8C, descriptors: [] },\n      { uuid: 0x2A98, descriptors: [] },\n      { uuid: 0x2A8E, descriptors: [] },\n      { uuid: 0x2A96, descriptors: [] },\n      { uuid: 0x2A8D, descriptors: [] },\n      { uuid: 0x2A92, descriptors: [] },\n      { uuid: 0x2A91, descriptors: [] },\n      { uuid: 0x2A7F, descriptors: [] },\n      { uuid: 0x2A83, descriptors: [] },\n      { uuid: 0x2A93, descriptors: [] },\n      { uuid: 0x2A86, descriptors: [] },\n      { uuid: 0x2A97, descriptors: [] },\n      { uuid: 0x2A8F, descriptors: [] },\n      { uuid: 0x2A88, descriptors: [] },\n      { uuid: 0x2A89, descriptors: [] },\n      { uuid: 0x2A7E, descriptors: [] },\n      { uuid: 0x2A84, descriptors: [] },\n      { uuid: 0x2A81, descriptors: [] },\n      { uuid: 0x2A82, descriptors: [] },\n      { uuid: 0x2A8B, descriptors: [] },\n      { uuid: 0x2A94, descriptors: [] },\n      { uuid: 0x2A95, descriptors: [] },\n      { uuid: 0x2A99, descriptors: [0x2902, ] },\n      { uuid: 0x2A9A, descriptors: [] },\n      { uuid: 0x2A9F, descriptors: [0x2902, ] },\n      { uuid: 0x2AA2, descriptors: [] },\n    ]\n  },\n  {\n    uuid: 0x181D,\n    characteristics: [\n      { uuid: 0x2A9E, descriptors: [] },\n      { uuid: 0x2A9D, descriptors: [0x2902, ] },\n    ]\n  },\n  // Medisana BS 430 Connect (Body Analysis Scale)\n  {\n    uuid: 0x78b2,\n    characteristics: [\n      { uuid: 0x8a20, descriptors: [] },\n      { uuid: 0x8a21, descriptors: [0x2902, ] },\n      { uuid: 0x8a22, descriptors: [0x2902, ] },\n      { uuid: 0x8a81, descriptors: [] },\n      { uuid: 0x8a82, descriptors: [0x2902, ] },\n    ]\n  }\n  // ---------------------------------------------\n  ];\n}\n\nrequire(\"cordova/exec/proxy\").add(\"BluetoothLePlugin\", module.exports);\n"}